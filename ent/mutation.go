// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"net/url"
	"sync"
	"time"

	"whoam.xyz/ent/method"
	"whoam.xyz/ent/oauth"
	"whoam.xyz/ent/permission"
	"whoam.xyz/ent/predicate"
	"whoam.xyz/ent/ras"
	"whoam.xyz/ent/service"
	"whoam.xyz/ent/user"

	"github.com/facebook/ent"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeMethod     = "Method"
	TypeOauth      = "Oauth"
	TypePermission = "Permission"
	TypeRAS        = "RAS"
	TypeService    = "Service"
	TypeUser       = "User"
)

// MethodMutation represents an operation that mutate the Methods
// nodes in the graph.
type MethodMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	route         *string
	scope         *method.Scope
	clearedFields map[string]struct{}
	owner         *int
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Method, error)
	predicates    []predicate.Method
}

var _ ent.Mutation = (*MethodMutation)(nil)

// methodOption allows to manage the mutation configuration using functional options.
type methodOption func(*MethodMutation)

// newMethodMutation creates new mutation for $n.Name.
func newMethodMutation(c config, op Op, opts ...methodOption) *MethodMutation {
	m := &MethodMutation{
		config:        c,
		op:            op,
		typ:           TypeMethod,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMethodID sets the id field of the mutation.
func withMethodID(id int) methodOption {
	return func(m *MethodMutation) {
		var (
			err   error
			once  sync.Once
			value *Method
		)
		m.oldValue = func(ctx context.Context) (*Method, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Method.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMethod sets the old Method of the mutation.
func withMethod(node *Method) methodOption {
	return func(m *MethodMutation) {
		m.oldValue = func(context.Context) (*Method, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MethodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MethodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MethodMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *MethodMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *MethodMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Method.
// If the Method object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MethodMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *MethodMutation) ResetName() {
	m.name = nil
}

// SetRoute sets the route field.
func (m *MethodMutation) SetRoute(s string) {
	m.route = &s
}

// Route returns the route value in the mutation.
func (m *MethodMutation) Route() (r string, exists bool) {
	v := m.route
	if v == nil {
		return
	}
	return *v, true
}

// OldRoute returns the old route value of the Method.
// If the Method object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MethodMutation) OldRoute(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoute is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoute requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoute: %w", err)
	}
	return oldValue.Route, nil
}

// ResetRoute reset all changes of the "route" field.
func (m *MethodMutation) ResetRoute() {
	m.route = nil
}

// SetScope sets the scope field.
func (m *MethodMutation) SetScope(value method.Scope) {
	m.scope = &value
}

// Scope returns the scope value in the mutation.
func (m *MethodMutation) Scope() (r method.Scope, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old scope value of the Method.
// If the Method object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MethodMutation) OldScope(ctx context.Context) (v method.Scope, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldScope is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ResetScope reset all changes of the "scope" field.
func (m *MethodMutation) ResetScope() {
	m.scope = nil
}

// SetOwnerID sets the owner edge to Service by id.
func (m *MethodMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the owner edge to Service.
func (m *MethodMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the edge owner was cleared.
func (m *MethodMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the owner id in the mutation.
func (m *MethodMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the owner ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *MethodMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner reset all changes of the "owner" edge.
func (m *MethodMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Op returns the operation name.
func (m *MethodMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Method).
func (m *MethodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MethodMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, method.FieldName)
	}
	if m.route != nil {
		fields = append(fields, method.FieldRoute)
	}
	if m.scope != nil {
		fields = append(fields, method.FieldScope)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MethodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case method.FieldName:
		return m.Name()
	case method.FieldRoute:
		return m.Route()
	case method.FieldScope:
		return m.Scope()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MethodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case method.FieldName:
		return m.OldName(ctx)
	case method.FieldRoute:
		return m.OldRoute(ctx)
	case method.FieldScope:
		return m.OldScope(ctx)
	}
	return nil, fmt.Errorf("unknown Method field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MethodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case method.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case method.FieldRoute:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoute(v)
		return nil
	case method.FieldScope:
		v, ok := value.(method.Scope)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	}
	return fmt.Errorf("unknown Method field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MethodMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MethodMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MethodMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Method numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MethodMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MethodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MethodMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Method nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MethodMutation) ResetField(name string) error {
	switch name {
	case method.FieldName:
		m.ResetName()
		return nil
	case method.FieldRoute:
		m.ResetRoute()
		return nil
	case method.FieldScope:
		m.ResetScope()
		return nil
	}
	return fmt.Errorf("unknown Method field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MethodMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, method.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MethodMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case method.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MethodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MethodMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MethodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, method.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MethodMutation) EdgeCleared(name string) bool {
	switch name {
	case method.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MethodMutation) ClearEdge(name string) error {
	switch name {
	case method.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Method unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MethodMutation) ResetEdge(name string) error {
	switch name {
	case method.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Method edge %s", name)
}

// OauthMutation represents an operation that mutate the Oauths
// nodes in the graph.
type OauthMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	expired_at     *time.Time
	refresh_token  *string
	clearedFields  map[string]struct{}
	owner          *int
	clearedowner   bool
	service        *int
	clearedservice bool
	done           bool
	oldValue       func(context.Context) (*Oauth, error)
	predicates     []predicate.Oauth
}

var _ ent.Mutation = (*OauthMutation)(nil)

// oauthOption allows to manage the mutation configuration using functional options.
type oauthOption func(*OauthMutation)

// newOauthMutation creates new mutation for $n.Name.
func newOauthMutation(c config, op Op, opts ...oauthOption) *OauthMutation {
	m := &OauthMutation{
		config:        c,
		op:            op,
		typ:           TypeOauth,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOauthID sets the id field of the mutation.
func withOauthID(id int) oauthOption {
	return func(m *OauthMutation) {
		var (
			err   error
			once  sync.Once
			value *Oauth
		)
		m.oldValue = func(ctx context.Context) (*Oauth, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Oauth.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOauth sets the old Oauth of the mutation.
func withOauth(node *Oauth) oauthOption {
	return func(m *OauthMutation) {
		m.oldValue = func(context.Context) (*Oauth, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OauthMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OauthMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *OauthMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *OauthMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *OauthMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Oauth.
// If the Oauth object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OauthMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *OauthMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetExpiredAt sets the expired_at field.
func (m *OauthMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the expired_at value in the mutation.
func (m *OauthMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old expired_at value of the Oauth.
// If the Oauth object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OauthMutation) OldExpiredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExpiredAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ResetExpiredAt reset all changes of the "expired_at" field.
func (m *OauthMutation) ResetExpiredAt() {
	m.expired_at = nil
}

// SetRefreshToken sets the refresh_token field.
func (m *OauthMutation) SetRefreshToken(s string) {
	m.refresh_token = &s
}

// RefreshToken returns the refresh_token value in the mutation.
func (m *OauthMutation) RefreshToken() (r string, exists bool) {
	v := m.refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old refresh_token value of the Oauth.
// If the Oauth object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OauthMutation) OldRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRefreshToken is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ResetRefreshToken reset all changes of the "refresh_token" field.
func (m *OauthMutation) ResetRefreshToken() {
	m.refresh_token = nil
}

// SetOwnerID sets the owner edge to User by id.
func (m *OauthMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the owner edge to User.
func (m *OauthMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the edge owner was cleared.
func (m *OauthMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the owner id in the mutation.
func (m *OauthMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the owner ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *OauthMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner reset all changes of the "owner" edge.
func (m *OauthMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetServiceID sets the service edge to Service by id.
func (m *OauthMutation) SetServiceID(id int) {
	m.service = &id
}

// ClearService clears the service edge to Service.
func (m *OauthMutation) ClearService() {
	m.clearedservice = true
}

// ServiceCleared returns if the edge service was cleared.
func (m *OauthMutation) ServiceCleared() bool {
	return m.clearedservice
}

// ServiceID returns the service id in the mutation.
func (m *OauthMutation) ServiceID() (id int, exists bool) {
	if m.service != nil {
		return *m.service, true
	}
	return
}

// ServiceIDs returns the service ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ServiceID instead. It exists only for internal usage by the builders.
func (m *OauthMutation) ServiceIDs() (ids []int) {
	if id := m.service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetService reset all changes of the "service" edge.
func (m *OauthMutation) ResetService() {
	m.service = nil
	m.clearedservice = false
}

// Op returns the operation name.
func (m *OauthMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Oauth).
func (m *OauthMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *OauthMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, oauth.FieldCreatedAt)
	}
	if m.expired_at != nil {
		fields = append(fields, oauth.FieldExpiredAt)
	}
	if m.refresh_token != nil {
		fields = append(fields, oauth.FieldRefreshToken)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *OauthMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauth.FieldCreatedAt:
		return m.CreatedAt()
	case oauth.FieldExpiredAt:
		return m.ExpiredAt()
	case oauth.FieldRefreshToken:
		return m.RefreshToken()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *OauthMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauth.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauth.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	case oauth.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	}
	return nil, fmt.Errorf("unknown Oauth field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OauthMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauth.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauth.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	case oauth.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	}
	return fmt.Errorf("unknown Oauth field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *OauthMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *OauthMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OauthMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Oauth numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *OauthMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *OauthMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *OauthMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Oauth nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *OauthMutation) ResetField(name string) error {
	switch name {
	case oauth.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauth.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	case oauth.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	}
	return fmt.Errorf("unknown Oauth field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *OauthMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, oauth.EdgeOwner)
	}
	if m.service != nil {
		edges = append(edges, oauth.EdgeService)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *OauthMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oauth.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case oauth.EdgeService:
		if id := m.service; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *OauthMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *OauthMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *OauthMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, oauth.EdgeOwner)
	}
	if m.clearedservice {
		edges = append(edges, oauth.EdgeService)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *OauthMutation) EdgeCleared(name string) bool {
	switch name {
	case oauth.EdgeOwner:
		return m.clearedowner
	case oauth.EdgeService:
		return m.clearedservice
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *OauthMutation) ClearEdge(name string) error {
	switch name {
	case oauth.EdgeOwner:
		m.ClearOwner()
		return nil
	case oauth.EdgeService:
		m.ClearService()
		return nil
	}
	return fmt.Errorf("unknown Oauth unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *OauthMutation) ResetEdge(name string) error {
	switch name {
	case oauth.EdgeOwner:
		m.ResetOwner()
		return nil
	case oauth.EdgeService:
		m.ResetService()
		return nil
	}
	return fmt.Errorf("unknown Oauth edge %s", name)
}

// PermissionMutation represents an operation that mutate the Permissions
// nodes in the graph.
type PermissionMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	owner          *int
	clearedowner   bool
	client         *int
	clearedclient  bool
	methods        map[int]struct{}
	removedmethods map[int]struct{}
	clearedmethods bool
	done           bool
	oldValue       func(context.Context) (*Permission, error)
	predicates     []predicate.Permission
}

var _ ent.Mutation = (*PermissionMutation)(nil)

// permissionOption allows to manage the mutation configuration using functional options.
type permissionOption func(*PermissionMutation)

// newPermissionMutation creates new mutation for $n.Name.
func newPermissionMutation(c config, op Op, opts ...permissionOption) *PermissionMutation {
	m := &PermissionMutation{
		config:        c,
		op:            op,
		typ:           TypePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionID sets the id field of the mutation.
func withPermissionID(id int) permissionOption {
	return func(m *PermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Permission
		)
		m.oldValue = func(ctx context.Context) (*Permission, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Permission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermission sets the old Permission of the mutation.
func withPermission(node *Permission) permissionOption {
	return func(m *PermissionMutation) {
		m.oldValue = func(context.Context) (*Permission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PermissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *PermissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *PermissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Permission.
// If the Permission object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PermissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *PermissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *PermissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *PermissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Permission.
// If the Permission object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PermissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *PermissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOwnerID sets the owner edge to User by id.
func (m *PermissionMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the owner edge to User.
func (m *PermissionMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the edge owner was cleared.
func (m *PermissionMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the owner id in the mutation.
func (m *PermissionMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the owner ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *PermissionMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner reset all changes of the "owner" edge.
func (m *PermissionMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetClientID sets the client edge to Service by id.
func (m *PermissionMutation) SetClientID(id int) {
	m.client = &id
}

// ClearClient clears the client edge to Service.
func (m *PermissionMutation) ClearClient() {
	m.clearedclient = true
}

// ClientCleared returns if the edge client was cleared.
func (m *PermissionMutation) ClientCleared() bool {
	return m.clearedclient
}

// ClientID returns the client id in the mutation.
func (m *PermissionMutation) ClientID() (id int, exists bool) {
	if m.client != nil {
		return *m.client, true
	}
	return
}

// ClientIDs returns the client ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ClientID instead. It exists only for internal usage by the builders.
func (m *PermissionMutation) ClientIDs() (ids []int) {
	if id := m.client; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClient reset all changes of the "client" edge.
func (m *PermissionMutation) ResetClient() {
	m.client = nil
	m.clearedclient = false
}

// AddMethodIDs adds the methods edge to Method by ids.
func (m *PermissionMutation) AddMethodIDs(ids ...int) {
	if m.methods == nil {
		m.methods = make(map[int]struct{})
	}
	for i := range ids {
		m.methods[ids[i]] = struct{}{}
	}
}

// ClearMethods clears the methods edge to Method.
func (m *PermissionMutation) ClearMethods() {
	m.clearedmethods = true
}

// MethodsCleared returns if the edge methods was cleared.
func (m *PermissionMutation) MethodsCleared() bool {
	return m.clearedmethods
}

// RemoveMethodIDs removes the methods edge to Method by ids.
func (m *PermissionMutation) RemoveMethodIDs(ids ...int) {
	if m.removedmethods == nil {
		m.removedmethods = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmethods[ids[i]] = struct{}{}
	}
}

// RemovedMethods returns the removed ids of methods.
func (m *PermissionMutation) RemovedMethodsIDs() (ids []int) {
	for id := range m.removedmethods {
		ids = append(ids, id)
	}
	return
}

// MethodsIDs returns the methods ids in the mutation.
func (m *PermissionMutation) MethodsIDs() (ids []int) {
	for id := range m.methods {
		ids = append(ids, id)
	}
	return
}

// ResetMethods reset all changes of the "methods" edge.
func (m *PermissionMutation) ResetMethods() {
	m.methods = nil
	m.clearedmethods = false
	m.removedmethods = nil
}

// Op returns the operation name.
func (m *PermissionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Permission).
func (m *PermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PermissionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.created_at != nil {
		fields = append(fields, permission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, permission.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldCreatedAt:
		return m.CreatedAt()
	case permission.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case permission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Permission field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case permission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PermissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PermissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Permission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PermissionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Permission nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PermissionMutation) ResetField(name string) error {
	switch name {
	case permission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case permission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, permission.EdgeOwner)
	}
	if m.client != nil {
		edges = append(edges, permission.EdgeClient)
	}
	if m.methods != nil {
		edges = append(edges, permission.EdgeMethods)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case permission.EdgeClient:
		if id := m.client; id != nil {
			return []ent.Value{*id}
		}
	case permission.EdgeMethods:
		ids := make([]ent.Value, 0, len(m.methods))
		for id := range m.methods {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmethods != nil {
		edges = append(edges, permission.EdgeMethods)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PermissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeMethods:
		ids := make([]ent.Value, 0, len(m.removedmethods))
		for id := range m.removedmethods {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, permission.EdgeOwner)
	}
	if m.clearedclient {
		edges = append(edges, permission.EdgeClient)
	}
	if m.clearedmethods {
		edges = append(edges, permission.EdgeMethods)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case permission.EdgeOwner:
		return m.clearedowner
	case permission.EdgeClient:
		return m.clearedclient
	case permission.EdgeMethods:
		return m.clearedmethods
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PermissionMutation) ClearEdge(name string) error {
	switch name {
	case permission.EdgeOwner:
		m.ClearOwner()
		return nil
	case permission.EdgeClient:
		m.ClearClient()
		return nil
	}
	return fmt.Errorf("unknown Permission unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PermissionMutation) ResetEdge(name string) error {
	switch name {
	case permission.EdgeOwner:
		m.ResetOwner()
		return nil
	case permission.EdgeClient:
		m.ResetClient()
		return nil
	case permission.EdgeMethods:
		m.ResetMethods()
		return nil
	}
	return fmt.Errorf("unknown Permission edge %s", name)
}

// RASMutation represents an operation that mutate the RASs
// nodes in the graph.
type RASMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	subject          *string
	post_uri         **url.URL
	redirect_uri     **url.URL
	state            *ras.State
	created_at       *time.Time
	clearedFields    map[string]struct{}
	organizer        *int
	clearedorganizer bool
	done             bool
	oldValue         func(context.Context) (*RAS, error)
	predicates       []predicate.RAS
}

var _ ent.Mutation = (*RASMutation)(nil)

// rasOption allows to manage the mutation configuration using functional options.
type rasOption func(*RASMutation)

// newRASMutation creates new mutation for $n.Name.
func newRASMutation(c config, op Op, opts ...rasOption) *RASMutation {
	m := &RASMutation{
		config:        c,
		op:            op,
		typ:           TypeRAS,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRASID sets the id field of the mutation.
func withRASID(id uuid.UUID) rasOption {
	return func(m *RASMutation) {
		var (
			err   error
			once  sync.Once
			value *RAS
		)
		m.oldValue = func(ctx context.Context) (*RAS, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RAS.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRAS sets the old RAS of the mutation.
func withRAS(node *RAS) rasOption {
	return func(m *RASMutation) {
		m.oldValue = func(context.Context) (*RAS, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RASMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RASMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on RAS creation.
func (m *RASMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RASMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSubject sets the subject field.
func (m *RASMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the subject value in the mutation.
func (m *RASMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old subject value of the RAS.
// If the RAS object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RASMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubject is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject reset all changes of the "subject" field.
func (m *RASMutation) ResetSubject() {
	m.subject = nil
}

// SetPostURI sets the post_uri field.
func (m *RASMutation) SetPostURI(u *url.URL) {
	m.post_uri = &u
}

// PostURI returns the post_uri value in the mutation.
func (m *RASMutation) PostURI() (r *url.URL, exists bool) {
	v := m.post_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldPostURI returns the old post_uri value of the RAS.
// If the RAS object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RASMutation) OldPostURI(ctx context.Context) (v *url.URL, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPostURI is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPostURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostURI: %w", err)
	}
	return oldValue.PostURI, nil
}

// ResetPostURI reset all changes of the "post_uri" field.
func (m *RASMutation) ResetPostURI() {
	m.post_uri = nil
}

// SetRedirectURI sets the redirect_uri field.
func (m *RASMutation) SetRedirectURI(u *url.URL) {
	m.redirect_uri = &u
}

// RedirectURI returns the redirect_uri value in the mutation.
func (m *RASMutation) RedirectURI() (r *url.URL, exists bool) {
	v := m.redirect_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURI returns the old redirect_uri value of the RAS.
// If the RAS object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RASMutation) OldRedirectURI(ctx context.Context) (v *url.URL, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRedirectURI is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRedirectURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURI: %w", err)
	}
	return oldValue.RedirectURI, nil
}

// ResetRedirectURI reset all changes of the "redirect_uri" field.
func (m *RASMutation) ResetRedirectURI() {
	m.redirect_uri = nil
}

// SetState sets the state field.
func (m *RASMutation) SetState(r ras.State) {
	m.state = &r
}

// State returns the state value in the mutation.
func (m *RASMutation) State() (r ras.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old state value of the RAS.
// If the RAS object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RASMutation) OldState(ctx context.Context) (v ras.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldState is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState reset all changes of the "state" field.
func (m *RASMutation) ResetState() {
	m.state = nil
}

// SetCreatedAt sets the created_at field.
func (m *RASMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *RASMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the RAS.
// If the RAS object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RASMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *RASMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOrganizerID sets the organizer edge to User by id.
func (m *RASMutation) SetOrganizerID(id int) {
	m.organizer = &id
}

// ClearOrganizer clears the organizer edge to User.
func (m *RASMutation) ClearOrganizer() {
	m.clearedorganizer = true
}

// OrganizerCleared returns if the edge organizer was cleared.
func (m *RASMutation) OrganizerCleared() bool {
	return m.clearedorganizer
}

// OrganizerID returns the organizer id in the mutation.
func (m *RASMutation) OrganizerID() (id int, exists bool) {
	if m.organizer != nil {
		return *m.organizer, true
	}
	return
}

// OrganizerIDs returns the organizer ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OrganizerID instead. It exists only for internal usage by the builders.
func (m *RASMutation) OrganizerIDs() (ids []int) {
	if id := m.organizer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganizer reset all changes of the "organizer" edge.
func (m *RASMutation) ResetOrganizer() {
	m.organizer = nil
	m.clearedorganizer = false
}

// Op returns the operation name.
func (m *RASMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (RAS).
func (m *RASMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RASMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.subject != nil {
		fields = append(fields, ras.FieldSubject)
	}
	if m.post_uri != nil {
		fields = append(fields, ras.FieldPostURI)
	}
	if m.redirect_uri != nil {
		fields = append(fields, ras.FieldRedirectURI)
	}
	if m.state != nil {
		fields = append(fields, ras.FieldState)
	}
	if m.created_at != nil {
		fields = append(fields, ras.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RASMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ras.FieldSubject:
		return m.Subject()
	case ras.FieldPostURI:
		return m.PostURI()
	case ras.FieldRedirectURI:
		return m.RedirectURI()
	case ras.FieldState:
		return m.State()
	case ras.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RASMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ras.FieldSubject:
		return m.OldSubject(ctx)
	case ras.FieldPostURI:
		return m.OldPostURI(ctx)
	case ras.FieldRedirectURI:
		return m.OldRedirectURI(ctx)
	case ras.FieldState:
		return m.OldState(ctx)
	case ras.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown RAS field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RASMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ras.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case ras.FieldPostURI:
		v, ok := value.(*url.URL)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostURI(v)
		return nil
	case ras.FieldRedirectURI:
		v, ok := value.(*url.URL)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURI(v)
		return nil
	case ras.FieldState:
		v, ok := value.(ras.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case ras.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RAS field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RASMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RASMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RASMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RAS numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RASMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RASMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RASMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RAS nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RASMutation) ResetField(name string) error {
	switch name {
	case ras.FieldSubject:
		m.ResetSubject()
		return nil
	case ras.FieldPostURI:
		m.ResetPostURI()
		return nil
	case ras.FieldRedirectURI:
		m.ResetRedirectURI()
		return nil
	case ras.FieldState:
		m.ResetState()
		return nil
	case ras.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown RAS field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RASMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.organizer != nil {
		edges = append(edges, ras.EdgeOrganizer)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RASMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ras.EdgeOrganizer:
		if id := m.organizer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RASMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RASMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RASMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorganizer {
		edges = append(edges, ras.EdgeOrganizer)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RASMutation) EdgeCleared(name string) bool {
	switch name {
	case ras.EdgeOrganizer:
		return m.clearedorganizer
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RASMutation) ClearEdge(name string) error {
	switch name {
	case ras.EdgeOrganizer:
		m.ClearOrganizer()
		return nil
	}
	return fmt.Errorf("unknown RAS unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RASMutation) ResetEdge(name string) error {
	switch name {
	case ras.EdgeOrganizer:
		m.ResetOrganizer()
		return nil
	}
	return fmt.Errorf("unknown RAS edge %s", name)
}

// ServiceMutation represents an operation that mutate the Services
// nodes in the graph.
type ServiceMutation struct {
	config
	op             Op
	typ            string
	id             *int
	service_id     *string
	name           *string
	subject        *string
	domain         *string
	clone_uri      *string
	clearedFields  map[string]struct{}
	methods        map[int]struct{}
	removedmethods map[int]struct{}
	clearedmethods bool
	done           bool
	oldValue       func(context.Context) (*Service, error)
	predicates     []predicate.Service
}

var _ ent.Mutation = (*ServiceMutation)(nil)

// serviceOption allows to manage the mutation configuration using functional options.
type serviceOption func(*ServiceMutation)

// newServiceMutation creates new mutation for $n.Name.
func newServiceMutation(c config, op Op, opts ...serviceOption) *ServiceMutation {
	m := &ServiceMutation{
		config:        c,
		op:            op,
		typ:           TypeService,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceID sets the id field of the mutation.
func withServiceID(id int) serviceOption {
	return func(m *ServiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Service
		)
		m.oldValue = func(ctx context.Context) (*Service, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Service.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withService sets the old Service of the mutation.
func withService(node *Service) serviceOption {
	return func(m *ServiceMutation) {
		m.oldValue = func(context.Context) (*Service, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ServiceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetServiceID sets the service_id field.
func (m *ServiceMutation) SetServiceID(s string) {
	m.service_id = &s
}

// ServiceID returns the service_id value in the mutation.
func (m *ServiceMutation) ServiceID() (r string, exists bool) {
	v := m.service_id
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceID returns the old service_id value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldServiceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldServiceID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldServiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceID: %w", err)
	}
	return oldValue.ServiceID, nil
}

// ResetServiceID reset all changes of the "service_id" field.
func (m *ServiceMutation) ResetServiceID() {
	m.service_id = nil
}

// SetName sets the name field.
func (m *ServiceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ServiceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ServiceMutation) ResetName() {
	m.name = nil
}

// SetSubject sets the subject field.
func (m *ServiceMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the subject value in the mutation.
func (m *ServiceMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old subject value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubject is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject reset all changes of the "subject" field.
func (m *ServiceMutation) ResetSubject() {
	m.subject = nil
}

// SetDomain sets the domain field.
func (m *ServiceMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the domain value in the mutation.
func (m *ServiceMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old domain value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDomain is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ResetDomain reset all changes of the "domain" field.
func (m *ServiceMutation) ResetDomain() {
	m.domain = nil
}

// SetCloneURI sets the clone_uri field.
func (m *ServiceMutation) SetCloneURI(s string) {
	m.clone_uri = &s
}

// CloneURI returns the clone_uri value in the mutation.
func (m *ServiceMutation) CloneURI() (r string, exists bool) {
	v := m.clone_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldCloneURI returns the old clone_uri value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldCloneURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCloneURI is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCloneURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloneURI: %w", err)
	}
	return oldValue.CloneURI, nil
}

// ResetCloneURI reset all changes of the "clone_uri" field.
func (m *ServiceMutation) ResetCloneURI() {
	m.clone_uri = nil
}

// AddMethodIDs adds the methods edge to Method by ids.
func (m *ServiceMutation) AddMethodIDs(ids ...int) {
	if m.methods == nil {
		m.methods = make(map[int]struct{})
	}
	for i := range ids {
		m.methods[ids[i]] = struct{}{}
	}
}

// ClearMethods clears the methods edge to Method.
func (m *ServiceMutation) ClearMethods() {
	m.clearedmethods = true
}

// MethodsCleared returns if the edge methods was cleared.
func (m *ServiceMutation) MethodsCleared() bool {
	return m.clearedmethods
}

// RemoveMethodIDs removes the methods edge to Method by ids.
func (m *ServiceMutation) RemoveMethodIDs(ids ...int) {
	if m.removedmethods == nil {
		m.removedmethods = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmethods[ids[i]] = struct{}{}
	}
}

// RemovedMethods returns the removed ids of methods.
func (m *ServiceMutation) RemovedMethodsIDs() (ids []int) {
	for id := range m.removedmethods {
		ids = append(ids, id)
	}
	return
}

// MethodsIDs returns the methods ids in the mutation.
func (m *ServiceMutation) MethodsIDs() (ids []int) {
	for id := range m.methods {
		ids = append(ids, id)
	}
	return
}

// ResetMethods reset all changes of the "methods" edge.
func (m *ServiceMutation) ResetMethods() {
	m.methods = nil
	m.clearedmethods = false
	m.removedmethods = nil
}

// Op returns the operation name.
func (m *ServiceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Service).
func (m *ServiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ServiceMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.service_id != nil {
		fields = append(fields, service.FieldServiceID)
	}
	if m.name != nil {
		fields = append(fields, service.FieldName)
	}
	if m.subject != nil {
		fields = append(fields, service.FieldSubject)
	}
	if m.domain != nil {
		fields = append(fields, service.FieldDomain)
	}
	if m.clone_uri != nil {
		fields = append(fields, service.FieldCloneURI)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ServiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case service.FieldServiceID:
		return m.ServiceID()
	case service.FieldName:
		return m.Name()
	case service.FieldSubject:
		return m.Subject()
	case service.FieldDomain:
		return m.Domain()
	case service.FieldCloneURI:
		return m.CloneURI()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ServiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case service.FieldServiceID:
		return m.OldServiceID(ctx)
	case service.FieldName:
		return m.OldName(ctx)
	case service.FieldSubject:
		return m.OldSubject(ctx)
	case service.FieldDomain:
		return m.OldDomain(ctx)
	case service.FieldCloneURI:
		return m.OldCloneURI(ctx)
	}
	return nil, fmt.Errorf("unknown Service field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ServiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case service.FieldServiceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceID(v)
		return nil
	case service.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case service.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case service.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case service.FieldCloneURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloneURI(v)
		return nil
	}
	return fmt.Errorf("unknown Service field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ServiceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ServiceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ServiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Service numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ServiceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ServiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Service nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ServiceMutation) ResetField(name string) error {
	switch name {
	case service.FieldServiceID:
		m.ResetServiceID()
		return nil
	case service.FieldName:
		m.ResetName()
		return nil
	case service.FieldSubject:
		m.ResetSubject()
		return nil
	case service.FieldDomain:
		m.ResetDomain()
		return nil
	case service.FieldCloneURI:
		m.ResetCloneURI()
		return nil
	}
	return fmt.Errorf("unknown Service field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ServiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.methods != nil {
		edges = append(edges, service.EdgeMethods)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ServiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case service.EdgeMethods:
		ids := make([]ent.Value, 0, len(m.methods))
		for id := range m.methods {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ServiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmethods != nil {
		edges = append(edges, service.EdgeMethods)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ServiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case service.EdgeMethods:
		ids := make([]ent.Value, 0, len(m.removedmethods))
		for id := range m.removedmethods {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ServiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmethods {
		edges = append(edges, service.EdgeMethods)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ServiceMutation) EdgeCleared(name string) bool {
	switch name {
	case service.EdgeMethods:
		return m.clearedmethods
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ServiceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Service unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ServiceMutation) ResetEdge(name string) error {
	switch name {
	case service.EdgeMethods:
		m.ResetMethods()
		return nil
	}
	return fmt.Errorf("unknown Service edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	email              *string
	clearedFields      map[string]struct{}
	oauths             map[int]struct{}
	removedoauths      map[int]struct{}
	clearedoauths      bool
	permissions        map[int]struct{}
	removedpermissions map[int]struct{}
	clearedpermissions bool
	done               bool
	oldValue           func(context.Context) (*User, error)
	predicates         []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEmail sets the email field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// AddOauthIDs adds the oauths edge to Oauth by ids.
func (m *UserMutation) AddOauthIDs(ids ...int) {
	if m.oauths == nil {
		m.oauths = make(map[int]struct{})
	}
	for i := range ids {
		m.oauths[ids[i]] = struct{}{}
	}
}

// ClearOauths clears the oauths edge to Oauth.
func (m *UserMutation) ClearOauths() {
	m.clearedoauths = true
}

// OauthsCleared returns if the edge oauths was cleared.
func (m *UserMutation) OauthsCleared() bool {
	return m.clearedoauths
}

// RemoveOauthIDs removes the oauths edge to Oauth by ids.
func (m *UserMutation) RemoveOauthIDs(ids ...int) {
	if m.removedoauths == nil {
		m.removedoauths = make(map[int]struct{})
	}
	for i := range ids {
		m.removedoauths[ids[i]] = struct{}{}
	}
}

// RemovedOauths returns the removed ids of oauths.
func (m *UserMutation) RemovedOauthsIDs() (ids []int) {
	for id := range m.removedoauths {
		ids = append(ids, id)
	}
	return
}

// OauthsIDs returns the oauths ids in the mutation.
func (m *UserMutation) OauthsIDs() (ids []int) {
	for id := range m.oauths {
		ids = append(ids, id)
	}
	return
}

// ResetOauths reset all changes of the "oauths" edge.
func (m *UserMutation) ResetOauths() {
	m.oauths = nil
	m.clearedoauths = false
	m.removedoauths = nil
}

// AddPermissionIDs adds the permissions edge to Permission by ids.
func (m *UserMutation) AddPermissionIDs(ids ...int) {
	if m.permissions == nil {
		m.permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the permissions edge to Permission.
func (m *UserMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared returns if the edge permissions was cleared.
func (m *UserMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the permissions edge to Permission by ids.
func (m *UserMutation) RemovePermissionIDs(ids ...int) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed ids of permissions.
func (m *UserMutation) RemovedPermissionsIDs() (ids []int) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the permissions ids in the mutation.
func (m *UserMutation) PermissionsIDs() (ids []int) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions reset all changes of the "permissions" edge.
func (m *UserMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldEmail:
		return m.Email()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.oauths != nil {
		edges = append(edges, user.EdgeOauths)
	}
	if m.permissions != nil {
		edges = append(edges, user.EdgePermissions)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeOauths:
		ids := make([]ent.Value, 0, len(m.oauths))
		for id := range m.oauths {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedoauths != nil {
		edges = append(edges, user.EdgeOauths)
	}
	if m.removedpermissions != nil {
		edges = append(edges, user.EdgePermissions)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeOauths:
		ids := make([]ent.Value, 0, len(m.removedoauths))
		for id := range m.removedoauths {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedoauths {
		edges = append(edges, user.EdgeOauths)
	}
	if m.clearedpermissions {
		edges = append(edges, user.EdgePermissions)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeOauths:
		return m.clearedoauths
	case user.EdgePermissions:
		return m.clearedpermissions
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeOauths:
		m.ResetOauths()
		return nil
	case user.EdgePermissions:
		m.ResetPermissions()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
